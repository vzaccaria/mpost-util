// Generated by LiveScript 1.2.0
(function(){
  var _, moment, fs, color, ref$, spawn, kill, __q, sh, os, shelljs, winston, debug, tex, just, unit, parse, parse1, parse0, seq, getName, getResults, getFstArray, getOptions, box, symtable, circle, join, drawArrow, array, col, row, diagram, line, steps, d, join$ = [].join, slice$ = [].slice;
  _ = require('underscore');
  _.str = require('underscore.string');
  moment = require('moment');
  fs = require('fs');
  color = require('ansi-color').set;
  ref$ = require('child_process'), spawn = ref$.spawn, kill = ref$.kill;
  __q = require('q');
  sh = require('shelljs');
  os = require('os');
  shelljs = sh;
  winston = require('winston');
  debug = require('debug')('metapost');
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  tex = function(text){
    return function(){
      return {
        result: "btex " + text + " etex",
        name: []
      };
    };
  };
  just = function(text){
    return function(){
      return {
        result: text,
        name: []
      };
    };
  };
  unit = "mm";
  parse = function(r, args){
    var o, nm, nodes, finalize, roots, nodeDef;
    o = getOptions(args);
    nm = getName(args);
    nodes = _.reduceRight(r, function(a, c){
      return a = a.concat(c.nodes);
    }, []);
    finalize = _.reduceRight(r, function(a, c){
      return a = a.concat(c.finalize);
    }, []);
    roots = r.map(function(it){
      return it.root;
    });
    nodeDef = join$.call(r.map(function(it){
      return it.nodeDef;
    }), "");
    nm == null && (nm = "undefined");
    return {
      opts: o,
      name: nm,
      nodes: nodes,
      nodeDef: nodeDef,
      roots: roots,
      finalize: finalize
    };
  };
  parse1 = function(args){
    var r;
    r = getResults(getFstArray(args));
    return parse(r, args);
  };
  parse0 = function(args){
    var r;
    r = getResults(args);
    return parse(r, args);
  };
  seq = function(args){
    return function(){
      return _.pick(parse0(args), 'nodeDef', 'nodes', 'finalize');
    };
  };
  getName = function(args){
    var i$, len$, a;
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (_.isString(a)) {
        return a;
      }
    }
    return undefined;
  };
  getResults = function(args){
    var res, i$, len$, a;
    res = [];
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (_.isFunction(a)) {
        res.push(a());
      }
    }
    return res;
  };
  getFstArray = function(args){
    var i$, len$, a;
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (_.isArray(a)) {
        return a;
      }
    }
    return [];
  };
  getOptions = function(args){
    var o, i$, len$, a;
    o = {};
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (!_.isFunction(a) && !_.isString(a)) {
        o = _.extend(o, a);
      }
    }
    return o;
  };
  box = function(){
    var args;
    args = slice$.call(arguments, 0);
    return function(){
      var name, o, res;
      name = getName(args);
      o = getOptions(args);
      res = "boxit";
      if (name != null) {
        res = res + ("." + name);
      }
      res = res + "(" + join$.call(getResults(args).map(function(it){
        return it.result;
      }), "") + ");";
      if ((o != null ? o.dx : void 8) != null) {
        res = res + line(name + ".dx = " + o.dx + ";");
      }
      if ((o != null ? o.dy : void 8) != null) {
        res = res + line(name + ".dy = " + o.dy + ";");
      }
      return {
        nodeDef: line(res),
        nodes: [name],
        root: name + ".c",
        finalize: line("drawboxed(" + name + ");")
      };
    };
  };
  symtable = {};
  circle = function(){
    var args;
    args = slice$.call(arguments, 0);
    return function(){
      var name, o, res;
      name = getName(args);
      o = getOptions(args);
      res = "circleit";
      if (name != null) {
        res = res + ("." + name);
      }
      res = res + "(" + join$.call(getResults(args).map(function(it){
        return it.result;
      }), "") + ");";
      if ((o != null ? o.dx : void 8) != null) {
        res = res + line(name + ".e - " + name + ".c = (" + o.dx + unit + ", 0);");
      }
      if ((o != null ? o.dy : void 8) != null) {
        res = res + line(name + ".n - " + name + ".c = (0, " + o.dy + unit + ");");
      }
      return {
        nodeDef: line(res),
        nodes: [name],
        root: name + ".c",
        finalize: line("drawboxed(" + name + ");")
      };
    };
  };
  join = function(){
    var args;
    args = slice$.call(arguments, 0);
    return function(){
      var ref$, opts, name, nodes, nodeDef, roots, res, finalize;
      ref$ = parse1(args), opts = ref$.opts, name = ref$.name, nodes = ref$.nodes, nodeDef = ref$.nodeDef, roots = ref$.roots;
      if ((opts != null ? opts.vertical : void 8) != null) {
        res = line("boxjoin(a.e=b.w);");
      }
      if ((opts != null ? opts.vertical : void 8) == null) {
        res = line("boxjoin(a.s=b.n);");
      }
      res = res + nodeDef;
      res = res + line("pair " + name + ".c; " + name + ".c = " + roots[0] + ";");
      finalize = line("drawboxed(" + join$.call(nodes, ',') + ");");
      return {
        nodeDef: line(res),
        nodes: nodes,
        root: name + ".c",
        finalize: finalize
      };
    };
  };
  drawArrow = function(){
    var args;
    args = slice$.call(arguments, 0);
    return function(){
      var r, o, res;
      r = getResults(args);
      o = getOptions(args);
      res = "";
      if (o.south != null) {
        res = res + line("drawarrow " + r[0].result + ".c{down} .. {curl 0}" + r[1].result + ".c;");
      }
      if (o.south == null) {
        res = res + line("drawarrow " + r[0].result + ".c{down} .. {curl 0}" + r[1].result + ".c;");
      }
      return {
        nodes: [],
        finalize: res
      };
    };
  };
  array = function(){
    var args;
    args = slice$.call(arguments, 0);
    return function(){
      var ref$, opts, name, nodes, nodeDef, roots, finalize, res, i, v;
      ref$ = parse1(args), opts = ref$.opts, name = ref$.name, nodes = ref$.nodes, nodeDef = ref$.nodeDef, roots = ref$.roots, finalize = ref$.finalize;
      opts.space == null && (opts.space = "1");
      if (opts.vertical != null) {
        opts.dist == null && (opts.dist = opts.space + "*(0,1" + unit + ")");
      }
      if (!opts.vertical) {
        opts.dist == null && (opts.dist = opts.space + "*(-1" + unit + ",0)");
      }
      res = "";
      res = res + nodeDef;
      res = res + line("pair " + name + ".c;");
      if (opts.rootAt != null) {
        res = res + line(name + ".c = " + opts.rootAt + ";");
      }
      for (i in roots) {
        v = roots[i];
        res = res + line(name + ".c - " + i + " * " + opts.dist + " = " + v + ";");
      }
      return {
        nodeDef: line(res),
        nodes: nodes,
        root: name + ".c",
        finalize: finalize
      };
    };
  };
  col = function(){
    var args;
    args = slice$.call(arguments, 0);
    return array.apply(array, args.concat([{
      vertical: true
    }]));
  };
  row = array;
  diagram = function(codebody){
    var ref$, nodeDef, nodes, finalize;
    ref$ = codebody(), nodeDef = ref$.nodeDef, nodes = ref$.nodes, finalize = ref$.finalize;
    return "input boxes;\nstring defaultfont;\ndefaultfont=\"pplr8r\";\nbeginfig(1);\n" + nodeDef + "\n" + join$.call(finalize, '') + "\nendfig;\nend;";
  };
  line = function(it){
    return "\n" + it;
  };
  steps = [
    row([
      join([box('q', tex("y")), box('r', tex("y"))], 'qr'), box('h', tex("$x^2$"), {
        dx: 30,
        dy: 20
      }), box('i', tex("x+3+1"), {
        dx: 30,
        dy: 20
      }), circle('j', tex("x+5+1"), {
        dx: 30,
        dy: 20
      }), box('k', tex("3+1"), {
        dx: 30,
        dy: 20
      }), box('l', tex("y"), {
        dx: 30,
        dy: 20
      }), box('m', tex("y"), {
        dx: 30,
        dy: 20
      })
    ], 'p', {
      space: "30"
    }), drawArrow(just('h'), just('j'))
  ];
  d = diagram(seq(steps));
  console.log(d);
}).call(this);
